# 简单高效，结合各种理论的模型，不需要大量的数据，可以系统做出决策
# 决策是指，面临多种方案时，需要依据一定的标准选择某一种方案

# 基本原理-步骤方法-应用-数学建模案例-优缺点分析

# 层次分析法将定量分析与定性分析结合起来，给出每个决策方案的标准权数。
# 根据权重求出各方案的优劣次序

# 三大典型应用：（1）最佳方案的选取--选择地址，
# （2）评价类问题--评价环境（3）指标体系的选取--（兼顾科学和效率）

# 基本原理：将问题分成不同的组合因素，并且将因素按照不同层次组合，形成一个多层次的分析结构
# 类似神经网络（？）

# 步骤--建立层次结构-构建判断矩阵-层次单排序，一致性检验-层次总排序，一致性检验
# 建立层次结构：最高层（决策的目的，解决的问题）--最底层（可选择的方案）--中间层（考虑的因素，决策的准则）
# 尽量列出三层的结构，要解决的问题是最底层对最高层的权重排序问题（还是神经网络）

# 构造判断矩阵 1.不把所有因素放在一起比较，而是两两相互比较
# 采用相对尺度，尽可能减少性质不同比较困难，提高准度。--每层不要超过9个因素
# 两个稍微重要一定是极端重要吗？这是一个需要考虑的问题

# 一致矩阵的性质--（1）秩=1，唯一非零特征根为n（矩阵为n*n）
# （2）非0特征根对应的特征向量归一化后可以作为权重向量
# 不一致阵的性质，对应于最大特征根的特征向量作为权重w

# 层次单排序和一致性检验
# 一致性检验：求出的W一定可以用作权重吗
# 当不一致越大时，兰姆大与n越大。CI是一致性检验的指标，越接近于0，一致性越大
# 为了衡量CI的大小，引入随机一致性指标RI，定义一致性比率：当CI/RI<0.1的时候，有满意的一致性
# 否则需要调整

# 正互反矩阵最大特征根和特征向量的简化计算：？似乎没用（）

# 层次总排序及一致性检验（此处特别像神经网络）
# 从最高层到最低层次依次进行，综合结果用矩阵求行和即可。权重*内容
# 得到层次总排序后，还需要进行总排序的一致性检验<0.1即可
# 1-建立层次模型结构 2-构造对比矩阵 3-单排序权重向量，进行一致性检验 4-计算总排序，一致性检验
# 本质上就是一个不断求权重的问题，重复的是一个过程：输入互反矩阵，输出权重向量，进行一致性检验，最后得到总的矩阵，再通过加权求和得到最后的评分值
# 以下为举例，注意理解过程
# 选人问题（还有一个经典是旅游问题）
# 小美要选男朋友了，现有小明、小李两个人选，到底该选谁呢？
# 现在小美要从四个指标去选择，分别是身高、颜值、学历、性格。小美对他们各个指标的评分如下
#     身高 颜值 学历 性格
# 小明 8   7   6    8
# 小李 7   8   8    7

# 导入相关库
import numpy as np


# 一致性检验函数
def consistency_check(A):
    EIG = np.linalg.eig(A)[0]  # eig函数返回矩阵的特征值和特征向量
    n = A.shape[0]
    CI = (max(EIG) - n) / (n - 1)
    RI = [0, 0, 0.52, 0.89, 1.12, 1.26, 1.36, 1.41, 1.46, 1.49, 1.52, 1.54, 1.56, 1.58, 1.59]
    CR = CI / RI[n - 1]
    CI = float(CI)
    CR = float(CR)  # 全部转换为实数
    print('The CI is:', CI)
    print('The CR is:', CR)
    if CR < 0.1:
        print('一致性检验通过')
        return 1
    else:
        print('一致性检验未通过')
        return 0  # 对CR进行判断，用于下面计算权重函数


p = np.mat('8 7 6 8;7 8 8 7')  # 每一行代表一个对象的指标评分
# A为自己构造的输入判别矩阵
A = np.array([[1, 3, 1, 1 / 3], [1 / 3, 1, 1 / 2, 1 / 5], [1, 2, 1, 1 / 3], [3, 5, 3, 1]])
# 查看行数和列数
[m, n] = A.shape

# 求特征值和特征向量
V, D = np.linalg.eig(A)
print('特征值：')
print(V)
print('特征向量：')
print(D)
# 最大特征值
tzz = np.max(V)
print(tzz)
# 最大特征向量
k = [i for i in range(len(V)) if V[i] == np.max(V)]
tzx = -D[:, k]
print(tzx)

# #赋权重
quan = np.zeros((n, 1))
for i in range(0, n):
    quan[i] = tzx[i] / np.sum(tzx)
Q = quan
print(Q)

# 一致性检验，当n=2时我们发现不需要进行一致性检验
consistency_check(A)
# 显示出所有评分对象的评分值
score = p * Q
for i in range(len(score)):
    print('object_score {}：'.format(i), float(score[i]))

# 输入问题规模，再输入问题的矩阵，直接解出最后的结果：各个权重是多少，哪一个最大
# 遗留问题：复数特征值怎么解决？
